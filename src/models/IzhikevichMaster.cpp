

/* This file was generated by PyPe9 version 0.1 on Thu 11 Feb 16 04:32:39PM */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"
#include "IzhikevichMaster.h"

/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::IzhikevichMaster> nineml::IzhikevichMaster::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::IzhikevichMaster>::create() {
    insert_("U", &nineml::IzhikevichMaster::get_y_elem_<nineml::IzhikevichMaster::State_::U_INDEX>);
    insert_("V", &nineml::IzhikevichMaster::get_y_elem_<nineml::IzhikevichMaster::State_::V_INDEX>);
  }
}

/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

extern "C" int IzhikevichMaster_dynamics(double t, const double y_[], double f_[], void* pnode_) {

	// Get references to the members of the model
	assert(pnode_);
	const IzhikevichMaster& node_ = *(reinterpret_cast<IzhikevichMaster*>(pnode_));
	const IzhikevichMaster::Parameters_& P_ = node_.P_;
	const IzhikevichMaster::State_& S_ = node_.S_;
	const IzhikevichMaster::Buffers_& B_ = node_.B_;

    if (B_.current_regime == IzhikevichMaster::subthreshold_regime_REGIME) {
	    // State Variables
        const double_t& V = S_.y_[IzhikevichMaster::State_::V_INDEX];  // (mV)
        const double_t& U = S_.y_[IzhikevichMaster::State_::U_INDEX];  // (mV/ms)
            
        
        // Parameters
        const double_t& zeta = P_.zeta;  // (mV/ms)
        const double_t& beta = P_.beta;  // (1/ms)
        const double_t& a = P_.a;  // (1/ms)
        const double_t& C_m = P_.C_m;  // (pF)
        const double_t& alpha = P_.alpha;  // (1/ms*mV)
        const double_t& b = P_.b;  // (1/ms)
        
        // Analog receive ports
        const double_t& Isyn = B_.Isyn_value;  // (pA)
        
        // Constants
        
        // Random variables
        
        // Aliases
        
	    // Evaluate differential equations
	    //std::cout << "U=" << a*(-U + V*b);
	    ITEM(f_, IzhikevichMaster::State_::U_INDEX) = a*(-U + V*b);  // (mV/ms^2)
	    //std::cout << "V=" << -U + V*beta + alpha*(V*V) + zeta + Isyn/C_m;
	    ITEM(f_, IzhikevichMaster::State_::V_INDEX) = -U + V*beta + alpha*(V*V) + zeta + Isyn/C_m;  // (mV/ms)
    }

    //std::cout << "Success at t=" << t << ": " << GSL_SUCCESS << std::endl;
    return GSL_SUCCESS;
}

/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/


/***********************
 * Steady-sate solvers *
 ***********************/



/***********************************************
 * Diagonal Jacobian approximation if required *
 ***********************************************/

/** Diagonal Jacobian approximation (for GSL): (f(s+.01) - f(s))/.001 */
extern "C" int IzhikevichMaster_jacobian (double t, const double y[], double *dfdy, double dfdt[], void* pnode) {
    // cast the node ptr to an object of the proper type
    assert(pnode);
    const IzhikevichMaster & node = *(reinterpret_cast<IzhikevichMaster*>(pnode));
    IzhikevichMaster & vnode =    *(reinterpret_cast<IzhikevichMaster*>(pnode));

    // state is a reference to the model state
    struct IzhikevichMaster::Buffers_ *b;
    b = &(vnode.B_);

    for (int i = 0; i < b->N; i++)
        b->u[i] = y[i] + 0.01;

    IzhikevichMaster_dynamics(t, b->u, b->jac, pnode);
    for (int i = 0; i < b->N; i++)
        dfdt[i*b->N + i] = (b->jac[i] - dfdy[i]) / .001;
    return 0;
}
/**********************************
 * Define parameters of the model *
 **********************************/

IzhikevichMaster::Parameters_::Parameters_():
    a (0.0),
    c (0.0),
    b (0.0),
    d (0.0),
    C_m (0.0),
    beta (0.0),
    theta (0.0),
    alpha (0.0),
    zeta (0.0) {
// Check constraints on parameters
}

/************************************
 * Construct state from parameters.
 ************************************/

IzhikevichMaster::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;

    // FIXME: need to add initial state here
    y_[U_INDEX] = 0.0;
    y_[V_INDEX] = 0.0;

}

/***********************************
 * Copy constructor for State class
 ***********************************/
IzhikevichMaster::State_::State_(const State_& s) {
  for (int i = 0 ; i < 2 ; ++i)
      y_[i] = s.y_[i];
}

/********************************************
 * Assignment of a State from another State *
 ********************************************/

IzhikevichMaster::State_& IzhikevichMaster::State_::operator=(const State_& s) {
  assert(this != &s);
  for (size_t i = 0 ; i < 2 ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void IzhikevichMaster::calibrate() {
    B_.logger_.init();
    V_.rng_ = net_->get_rng( get_thread() );
}

/***************************
 * Accessors and Modifiers *
 ***************************/

void IzhikevichMaster::Parameters_::get (DictionaryDatum &d_) const {

    // Update dictionary from internal parameters, scaling if required.
    def<double_t>(d_, "a", a);
    def<double_t>(d_, "c", c);
    def<double_t>(d_, "b", b);
    def<double_t>(d_, "d", d);
    def<double_t>(d_, "C_m", C_m);
    def<double_t>(d_, "beta", beta);
    def<double_t>(d_, "theta", theta);
    def<double_t>(d_, "alpha", alpha);
    def<double_t>(d_, "zeta", zeta);

}

void IzhikevichMaster::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
    updateValue<double_t>(d_, "a", a);
    updateValue<double_t>(d_, "c", c);
    updateValue<double_t>(d_, "b", b);
    updateValue<double_t>(d_, "d", d);
    updateValue<double_t>(d_, "C_m", C_m);
    updateValue<double_t>(d_, "beta", beta);
    updateValue<double_t>(d_, "theta", theta);
    updateValue<double_t>(d_, "alpha", alpha);
    updateValue<double_t>(d_, "zeta", zeta);

    // Scale parameters as required
}

void IzhikevichMaster::State_::get (DictionaryDatum &d_) const {
    // Get states from internal variables
    def<double_t>(d_, "U", y_[0]);
    def<double_t>(d_, "V", y_[1]);
}

void IzhikevichMaster::State_::set (const DictionaryDatum &d_, const Parameters_&) {
    // Set internal state variables from dictionary values
    updateValue<double_t>(d_, "U", y_[0]);
    updateValue<double_t>(d_, "V", y_[1]);
}

/***********
 * Buffers *
 ***********/

IzhikevichMaster::Buffers_::Buffers_(IzhikevichMaster& n)
    : logger_(n),
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0),      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

IzhikevichMaster::Buffers_::Buffers_(const Buffers_&, IzhikevichMaster& n)
    : logger_(n),
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0),      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void IzhikevichMaster::init_buffers_() {

    // Clear event buffers

    // Clear analog buffers
    B_.Isyn_analog_port.clear();

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();
    B_.IntegrationStep_ = B_.step_;

    B_.Isyn_value = 0.0;

    static const gsl_odeiv2_step_type* T1 = gsl_odeiv2_step_rk2;
    B_.N = 2;

    if ( B_.s_ == 0 )
        B_.s_ = gsl_odeiv2_step_alloc (T1, B_.N);
    else
        gsl_odeiv2_step_reset(B_.s_);

    if ( B_.c_ == 0 )
        B_.c_ = gsl_odeiv2_control_standard_new (0.001, 0.0, 1.0, 0.0);
    else
        gsl_odeiv2_control_init(B_.c_, 0.001, 0.0, 1.0, 0.0);

    if ( B_.e_ == 0 )
        B_.e_ = gsl_odeiv2_evolve_alloc(B_.N);
    else
        gsl_odeiv2_evolve_reset(B_.e_);

    B_.sys_.function  = IzhikevichMaster_dynamics;
    B_.sys_.jacobian  = IzhikevichMaster_jacobian;
    B_.sys_.dimension = B_.N;
    B_.sys_.params    = reinterpret_cast<void*>(this);

    B_.u = (double *)malloc(sizeof(double) * B_.N);
    assert (B_.u);
    B_.jac = (double *)malloc(sizeof(double) * B_.N);
    assert (B_.jac);}

/****************
 * Constructors *
 ****************/

IzhikevichMaster::IzhikevichMaster()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {

    recordablesMap_.create();

    double t = 0.0;
    // State Variables
    const double_t& V = S_.y_[IzhikevichMaster::State_::V_INDEX];  // (mV)
        
    
    // Parameters
    const double_t& theta = P_.theta;  // (mV)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    B_.subthreshold_regime_trigger_0_active = !(V > theta);
}

IzhikevichMaster::IzhikevichMaster(const IzhikevichMaster& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {}

void IzhikevichMaster::init_node_(const Node& proto) {
    const IzhikevichMaster& pr = downcast<IzhikevichMaster>(proto);
    P_ = pr.P_;
    S_ = State_(P_);

    double t = 0.0;
    // State Variables
    const double_t& V = S_.y_[IzhikevichMaster::State_::V_INDEX];  // (mV)
        
    
    // Parameters
    const double_t& theta = P_.theta;  // (mV)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    B_.subthreshold_regime_trigger_0_active = !(V > theta);    
}

void IzhikevichMaster::init_state_(const Node& proto) {
    const IzhikevichMaster& pr = downcast<IzhikevichMaster>(proto);
    S_ = State_(pr.P_);

    double t = 0.0;
    // State Variables
    const double_t& V = S_.y_[IzhikevichMaster::State_::V_INDEX];  // (mV)
        
    
    // Parameters
    const double_t& theta = P_.theta;  // (mV)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    B_.subthreshold_regime_trigger_0_active = !(V > theta);    
}

/**************
 * Destructor *
 **************/

IzhikevichMaster::~IzhikevichMaster () {
    // GSL structs only allocated by init_nodes_(),
    // so we need to protect destruction
    if ( B_.s_ != NULL)
        gsl_odeiv2_step_free (B_.s_);
    if ( B_.c_ != NULL)
        gsl_odeiv2_control_free (B_.c_);
    if ( B_.e_ != NULL)
        gsl_odeiv2_evolve_free (B_.e_);
    if ( B_.u != NULL)
        free (B_.u);
    if ( B_.jac != NULL)
        free (B_.jac);}

/************************************************************************
 * Function to be solved for its roots be solver to exact trigger times *
 ************************************************************************/


/***********************
 * Evaluate the update *
 ***********************/

void IzhikevichMaster::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    double dt = nest::Time::get_resolution().get_ms();
    nest::long_t current_steps = origin.get_steps();

    double f_[IzhikevichMaster::State_::STATE_VEC_SIZE_];  // Vector to hold the time derivatives

    for (nest::long_t lag = from; lag < to; ++lag) {

        /***** Solve ODE over timestep *****/

        if (B_.current_regime == subthreshold_regime_REGIME) {

            /***** Set clamp vars for state variables that don't have a time derivative in this regime *****/
 

	        double tt = 0.0;
	        while (tt < dt) {
	            const int status =  gsl_odeiv2_evolve_apply(
	                B_.e_, B_.c_, B_.s_,
	                &B_.sys_, // system of ODE
	                &tt, // from t...
	                dt, // ...to t= t + dt
	                &B_.IntegrationStep_, // integration window (written on!)
	                S_.y_); // neuron state
	            if (status != GSL_SUCCESS)
	              throw nest::GSLSolverFailure(get_name(), status);
	        }    
            /***** Reset state variables from clamp vars for state variables that don't have a time derivative in this regime *****/
    

        } 

        /***** Transition handling *****/
        int transition_count = 0;
        double prev_t = -std::numeric_limits<double>::infinity();
        int transitioned_to;
        
        do {
            transitioned_to = -1;
	        if (B_.current_regime == subthreshold_regime_REGIME) {
	            // Map all variables/expressions to the local namespace that are required to evaluate the triggers
	            // State Variables
                const double_t& V = S_.y_[IzhikevichMaster::State_::V_INDEX];  // (mV)
                    
                
                // Parameters
                const double_t& theta = P_.theta;  // (mV)
                
                // Analog receive ports
                
                // Constants
                
                // Random variables
                
                // Aliases
                
		        
		        // FIXME: The transitions should be ordered by the exact time they occur to determine which should be executed first.

                // Get the time after the current step to test the trigger against
                double t = origin.get_ms() + lag * dt;        
	            // Check trigger condition
	            if (V > theta) {
	            
	                // Check to see if trigger is active (i.e. was false since on the change from false->true triggers a transition)
	                if (B_.subthreshold_regime_trigger_0_active) {
	                    // Deactivate the trigger (triggers are only triggered when the change from false -> true)
	                    B_.subthreshold_regime_trigger_0_active = false; 
	                    prev_t = t;
                        // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers
                        // State Variables
                        const double_t& U = S_.y_[IzhikevichMaster::State_::U_INDEX];  // (mV/ms)
                            
                        
                        // Parameters
                        const double_t& c = P_.c;  // (mV)
                        const double_t& d = P_.d;  // (mV/ms)
                        
                        // Analog receive ports
                        
                        // Constants
                        
                        // Random variables
                        
                        // Aliases
                        

				        // State assignments
				        S_.y_[IzhikevichMaster::State_::U_INDEX] = U + d;  // (mV/ms)
				        S_.y_[IzhikevichMaster::State_::V_INDEX] = c;  // (mV)

					    // FIXME: Need to specify different output ports in a way that can be read by the receiving nodes
					    // Output events
					    set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
					    nest::SpikeEvent se;
					    network()->send(*this, se, lag);
        
                        // Set transition to new regime
                        B_.current_regime = transitioned_to = subthreshold_regime_REGIME;
                        // FIXME: Need to work out the best way to emit a warning in NEST.                                    
                        if (transitioned_to != -1)  // If have already transitioned to a new regime, emit a warning. FIXME: This should be an error.
	                        std::cout << "Warning!: multiple transitions in the same time step. Transition to 'Regime " << transitioned_to << "' was ignored in favour of transition " << subthreshold_regime_REGIME << "." << std::endl;
        
                        B_.subthreshold_regime_trigger_0_active = !(V > theta);
                        
                        // Increment the number of transitions that have occurred in this time step.
                        ++transition_count;
                                
	                }
	            } else
                    // Activate the trigger
                    B_.subthreshold_regime_trigger_0_active = true;
 
            }            
        } while (transitioned_to != -1 && transition_count < 1000);
            
        if (transition_count >= 1000) {
            //FIXME: This should be an error not a warning.
            std::cout << "Warning!: Number of instantaneous transitions exceeds maxiumum number set by 'max_simultaneous_transitions' template parameter (1000)" << std::endl;
        } else if (transition_count > 0) {
            /* Resets the GSL stepping function if any synaptic events have occurred */
            // gsl_odeiv2_step_reset(B_.s_);
            // gsl_odeiv2_evolve_reset(B_.e_);
        }

        /***** Get analog port values *****/
        B_.Isyn_value = B_.Isyn_analog_port.get_value(lag);

        /***** Record data *****/
        B_.logger_.record_data(current_steps + lag);
    }
}

/*****************
 * Event Handles *
 *****************/

void IzhikevichMaster::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);
    // Loop through event receive ports
}

void IzhikevichMaster::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();    
    // Loop through analog receive ports
    if (e.get_rport() == Isyn_ANALOG_PORT) {
        B_.Isyn_analog_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()), w * c);
    }
}

void IzhikevichMaster::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}

}  // End 'nineml' namespace

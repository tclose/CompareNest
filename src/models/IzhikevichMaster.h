/* This file was generated by PyPe9 version 0.1 on Thu 11 Feb 16 04:32:39PM */

#ifndef IZHIKEVICHMASTER_H
#define IZHIKEVICHMASTER_H

#include "nest.h"
#include "event.h"
#include "archiving_node.h"
#include "ring_buffer.h"
#include "connection.h"
#include "universal_data_logger.h"
#include "recordables_map.h"
#include "dictutils.h"

#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_sf_exp.h>
#include <gsl/gsl_odeiv2.h>

#include "../random.h"

#define ITEM(v,i)  (v[i])
namespace nineml {


    extern "C" int IzhikevichMaster_dynamics(double t, const double y_[], double f_[], void* pnode_);

    class IzhikevichMaster : public nest::Archiving_Node {

      public:

        ~IzhikevichMaster();
	    IzhikevichMaster(const IzhikevichMaster &);
	    IzhikevichMaster();

	    /**
	     * Import sets of overloaded virtual functions.
	     * This is necessary to ensure proper overload and overriding resolution.
	     * @see http://www.gotw.ca/gotw/005.htm.
	     */
	    using nest::Node::handle;
	    using nest::Node::handles_test_event;

	    nest::port send_test_event(nest::Node&, nest::port, nest::synindex, bool);

	    void handle(nest::SpikeEvent &);
	    void handle(nest::CurrentEvent &);
	    void handle(nest::DataLoggingRequest &);

	    nest::port handles_test_event(nest::SpikeEvent &, nest::port);
	    nest::port handles_test_event(nest::CurrentEvent &, nest::port);
	    nest::port handles_test_event(nest::DataLoggingRequest &, nest::port);

	    void get_status(DictionaryDatum &) const;
	    void set_status(const DictionaryDatum &);

	    void init_node_(const nest::Node& proto);
	    void init_state_(const nest::Node& proto);
	    void init_buffers_();
	    void calibrate();
	    
	    /* Inline random distribution methods */
        float random_uniform_(float low, float high);
        float random_normal_(float mu, float sigma);
        float random_exponential_(float lambda);   

	    void update(nest::Time const &, const nest::long_t, const nest::long_t);

    // Set dynamics methods (the ones that actually model the dynamics) as friends
	    friend int IzhikevichMaster_dynamics(double t, const double y_[], double f_[], void* pnode_);

	    // Regime ids
	    static const int DEFAULT_REGIME_ = 0;
	    enum Regimes {
	        subthreshold_regime_REGIME = DEFAULT_REGIME_,
	        SUP_REGIME_
	    };

	    /* Event port ids
	     * @note Start with 1 so we can forbid port 0 to avoid accidental
	     *     creation of connections with no receptor type set.
	     */
	    static const nest::port MIN_EVENT_PORT_ = 1;
	    enum EventPorts {
	        SUP_EVENT_PORT_
	    };

	    // On event ids
	    enum OnEvents {
	        SUP_ON_EVENT_
	    };

	    //Analog port ids
	    static const nest::port MIN_ANALOG_PORT_ = 1;
	    enum AnalogPorts {
            Isyn_ANALOG_PORT = MIN_ANALOG_PORT_,
            SUP_ANALOG_PORT_
        };

        // Synaptic event function definitions

	    // The next two classes need to be friends to access the State_ class/member
	    friend class nest::RecordablesMap<IzhikevichMaster>;
	    friend class nest::UniversalDataLogger<IzhikevichMaster>;

        struct Parameters_ {
            double a;
            double c;
            double b;
            double d;
            double C_m;
            double beta;
            double theta;
            double alpha;
            double zeta;
	        Parameters_();
	        void get(DictionaryDatum&) const;
	        void set(const DictionaryDatum&);
	    }; // end struct Parameters_

	    struct State_ {

            enum StateVecElems {
                U_INDEX = 0,
                V_INDEX,
                STATE_VEC_SIZE_
            };

            double y_[STATE_VEC_SIZE_];

	        State_(const Parameters_& p);
	        State_(const State_& s);
	        State_& operator=(const State_& s);
	        void get(DictionaryDatum&) const;
	        void set(const DictionaryDatum&, const Parameters_&);
	    }; // end struct State_

        struct Variables_ {
		    librandom::RngPtr rng_;           // random number generator of thread
        };

        struct Buffers_ {
	        Buffers_(IzhikevichMaster&);
	        Buffers_(const Buffers_&, IzhikevichMaster&);
	        nest::UniversalDataLogger<IzhikevichMaster> logger_;

            // Structures required by the solver
	        gsl_odeiv2_step*  s_;  //!< stepping function
	        gsl_odeiv2_control* c_;  //!< adaptive stepsize control function
	        gsl_odeiv2_evolve*  e_;  //!< evolution function
	        gsl_odeiv2_system   sys_;  //!< struct describing system
	        unsigned int N;  // size of state vector used by Jacobian
	        double *u, *jac;  // intermediate state vectors used for Jacobian approximation
	        // Timesteps
	        double_t step_;       //!< step size in ms
	        double   IntegrationStep_;//!< current integration time step, updated by solver

	        // Event receive port buffers

            // Analog receive port buffers
            nest::RingBuffer Isyn_analog_port;

            // Variables to hold the last value of the analog receive port buffers
            double_t Isyn_value;

            // Flags to signify whether the triggers are active (i.e. evaluated to false in the last time step)
            bool subthreshold_regime_trigger_0_active;

            // Holds the id of the current regime
            int current_regime;

	    }; // end struct Buffers_

		template <State_::StateVecElems elem>
		double_t get_y_elem_() const { return S_.y_[elem]; }

		Parameters_ P_;
		State_      S_;
		Variables_  V_;
		Buffers_    B_;

	    //! Mapping of recordables names to access functions	
		static nest::RecordablesMap<IzhikevichMaster> recordablesMap_;
    
	}; // end class IzhikevichMaster

    inline nest::port IzhikevichMaster::send_test_event(nest::Node& target, nest::port receptor_type, nest::synindex, bool) {
		nest::SpikeEvent e;
		e.set_sender(*this);
		return target.handles_test_event(e, receptor_type);
    }

    inline nest::port IzhikevichMaster::handles_test_event(nest::SpikeEvent&, nest::port receptor_type) {
	    if (receptor_type < 0 || receptor_type >= SUP_EVENT_PORT_)
            throw nest::UnknownReceptorType(receptor_type, this->get_name());
        else if (receptor_type < MIN_EVENT_PORT_)
            throw nest::IncompatibleReceptorType(receptor_type, this->get_name(), "SpikeEvent");
		return receptor_type;
    }

    inline nest::port IzhikevichMaster::handles_test_event(nest::CurrentEvent&, nest::port receptor_type) {
		if (receptor_type < 0 || receptor_type >= SUP_ANALOG_PORT_)
		    throw nest::UnknownReceptorType(receptor_type, this->get_name());
		else if (receptor_type < MIN_ANALOG_PORT_)
		    throw nest::IncompatibleReceptorType(receptor_type, this->get_name(), "SpikeEvent");
	    return receptor_type;
	}

	inline nest::port IzhikevichMaster::handles_test_event(nest::DataLoggingRequest& dlr, nest::port receptor_type) {
	    if (receptor_type != 0)
            throw nest::UnknownReceptorType(receptor_type, this->get_name());
		return B_.logger_.connect_logging_device( dlr, recordablesMap_ );
    }

    inline void IzhikevichMaster::get_status(DictionaryDatum &d) const {
		P_.get(d);
		S_.get(d);
		nest::Archiving_Node::get_status(d);
		(*d)[nest::names::recordables] = recordablesMap_.get_list();
		def<double_t>(d, nest::names::t_spike, get_spiketime_ms());
		DictionaryDatum receptor_dict_ = new Dictionary();
		// Synaptic event dictionary
        (*receptor_dict_)[Name("Isyn")]  = Isyn_ANALOG_PORT;
        (*d)[nest::names::receptor_types] = receptor_dict_;
    }

    inline void IzhikevichMaster::set_status(const DictionaryDatum &d) {
	    Parameters_ ptmp = P_;  // temporary copy in case of errors
	    ptmp.set(d);             // throws if BadProperty
	    State_    stmp = S_;  // temporary copy in case of errors
	    stmp.set(d, ptmp);         // throws if BadProperty
	    // We now know that (ptmp, stmp) are consistent. We do not
	    // write them back to (P_, S_) before we are also sure that
		// the properties to be set in the parent class are internally
		// consistent.
		nest::Archiving_Node::set_status(d);
		// if we get here, temporaries contain consistent set of properties
		P_ = ptmp;
		S_ = stmp;	
	    calibrate();
    }
    
    /* Inline random distributions (for deprecated format random.*), copied
       from the corresponding NEST random deviate implementations in librandom
       but stripped from RandomDeviate boiler plate */
    
    inline float IzhikevichMaster::random_uniform_(float low, float high) {
        return low + (high - low) * V_.rng_->drand();
    }

    inline float IzhikevichMaster::random_normal_(float mu, float sigma) {
        // Box-Muller algorithm, see Knuth TAOCP, vol 2, 3rd ed, p 122
        // we waste one number
        double V1;
        double V2;
        double S;

        do {
            V1 = 2 * V_.rng_->drand() - 1;
            V2 = 2 * V_.rng_->drand() - 1;
            S = V1 * V1 + V2 * V2;
        } while ( S >= 1 );

        if ( S != 0 )
            S = V1 * std::sqrt( -2 * std::log( S ) / S );
        return mu + sigma * S;
    }
    
    inline float IzhikevichMaster::random_exponential_(float lambda) {
        return -std::log(V_.rng_->drandpos()) / lambda;
    }   
    

} // end namespace nest

#endif // IZHIKEVICHMASTER_H
